{"hash":"5394c861f582412b8a8e90e81f5962b9adc78625","data":{"tag":{"title":"PS4","slug":"ps4","path":"/tag/ps4/","belongsTo":{"edges":[{"node":{"title":"Adventures of porting MUSL to PS4","path":"/posts/adventures-of-porting-musl-to-ps4/","date":"24 May 2020","description":"Over the last year or so, I've been working with the OpenOrbis team to develop a toolchain for building homebrew for the PS4, and one of the challenges we faced was porting a proper libc to the console. This article dives into some of the interesting lessons learned while porting MUSL to the PS4.","content":"<!--kg-card-begin: markdown--><p>Over the last year or so, I've been working with the OpenOrbis team to develop a toolchain for building homebrew to the PS4 without violating copyright laws by using the official SDK materials. This is not an easy task, building homebrew that will run on the system without official tools presents many challenges. Key among these challenges were:</p>\n<ul>\n<li>The executables use a customized ELF format that enables functionality unique to the console.</li>\n<li>The libc library used by Sony does not adhere to standards other libc libraries adhere to.</li>\n<li>We cannot redistribute sony libraries with the toolchain for legal reasons.</li>\n</ul>\n<p>While tackling the custom ELF format was an interesting task that I may go into in the future, the process of porting <a href=\"https://musl.libc.org/\">MUSL</a> also offered interesting hurdles and lessons.</p>\n<h2 id=\"overviewoflibc\">Overview of libc</h2>\n<p>Many developers treat libc as a black-box, they don't care how libc works, they just care that it does. This is perfectly fine when targeting an established platform that has a mature libc already working on it. When porting to a new platform however, you need to go into the nitty gritty details, because libc essentially acts as the glue between userland and kernel. For example, you will very rarely see userland applications issue system calls directly, but this is common-place in the world of libc. So if we break libc down, what are the fundamental components that are provided by libc to applications?</p>\n<ol>\n<li>The C Runtime (CRT) stub for initializing the environment, typically known as <code>crt1.o</code>.</li>\n<li>A layer to abstract common functionality (ie. file I/O, networking, data types, memory management) away from the platform's low-level interface (system calls, sysctls/ioctls, etc).</li>\n<li>Type definitions and objects for things like stdin, stdout, stderr, and error handling (errno).</li>\n</ol>\n<p>These components must be tailored to the operating system and architecture being targeted.</p>\n<h2 id=\"comparingbsdlibcandmusl\">Comparing BSD libc and MUSL</h2>\n<p>For those not familiar with PS4 internals, it's a FreeBSD based system, based on FreeBSD 9.0. Sony added their own system calls and modified some existing kernel code while also running a custom userland, but most of the standard syscalls are still pretty similar. Given it's a BSD system at base, one might ask; why not use BSD libc instead of MUSL - after all, it should match what the system exposes more closely? Knowing this, I decided to give it a shot. Here are some of my observations of both BSD libc and MUSL.</p>\n<p><strong>BSD libc</strong></p>\n<ol>\n<li>It was assumed BSD libc would work out of the box with minor CRT stub changes. It built without issue, but at runtime, this didn't end up being the case. Even something as simple as <code>sprintf()</code> failed with EINVAL, which is pretty incredible considering that's not even listed as a possible return value in the MAN pages. Bummer.</li>\n<li>It requires a BSD system to build it, and you build it by building &quot;BSD world&quot;, which is massive and includes more than just libc. Navigating the codebase was far more difficult, and the code was less easy to work with.</li>\n<li>Because of how much of a behemoth BSD world is, the build times were extremely long.</li>\n</ol>\n<p><strong>MUSL</strong></p>\n<ol>\n<li>MUSL definitely wouldn't work out of the box without some significant changes, as it's a Linux-based libc and we're dealing with BSD. Even getting it to build required changes.</li>\n<li>Unlike BSD world, MUSL is just a libc (and a minimal one at that). Fixing things was relatively easy and the code was readable and easily understood even if you're not familiar with the codebase.</li>\n<li>MUSL build times were blazingly fast compared to BSD libc. Where BSD libc would take about 20 minutes to build, building MUSL took closer to 2 minutes.</li>\n</ol>\n<p>Even though in theory porting MUSL would take more changes than building a modified BSD libc, MUSL was the better option when we considered how much easier it was to work with and how much faster it was to build.</p>\n<h2 id=\"acustomcrtstub\">A custom CRT stub</h2>\n<p>Most of the time, in C programs, <code>main()</code> is not the true entry-point. While it's the entry-point as far as the application author is concerned, the real endpoint is usually <code>_start()</code> unless changed in the compiler flags or by a pre-processor directive. The reason for this is the C runtime wants to initialize it's environment before running any user-code. This is handled by the CRT stub. The bulk of the C runtime bootstrapping code is contained in the <code>crt1.o</code> object file. Generally in this file, you have the entry-point <code>_start()</code>, which calls <code>__libc_start_main()</code>, passing the address of the user-defined <code>main()</code> which <code>__libc_start-main()</code> will execute after it finishes initializing environment-related stuff.</p>\n<p>The PS4 is a little different in this regard, because the PS4 doesn't have a conventional environment or set of arguments provided to it. As a matter of fact, the PS4 doesn't even want applications to ever return, as attempting to return from main() will crash the game. This makes sense, as games do not need or use arguments, and games should never return unless the player quits the game or application. With this in mind, I ignored <code>__libc_start_main()</code> and defined my own <code>_start()</code> which matches closer to the one produced by BSD libc.</p>\n<pre><code class=\"language-c\">__asm__(\n&quot;.intel_syntax noprefix \\n&quot;\n&quot;.global &quot; START &quot; \\n&quot;\nSTART &quot;: \\n&quot;\n\t&quot;sub rsp, 0x28 \\n&quot;\n\t&quot;mov rdi, r8 \\n&quot;\n\t&quot;call atexit \\n&quot;\n\t&quot;xor edx, edx \\n&quot;\n\t&quot;mov edi, r9d \\n&quot;\n\t&quot;mov rsi, r10 \\n&quot;\n\t&quot;call main \\n&quot;\n\t&quot;mov r11d, eax \\n&quot;\n\t&quot;mov edi, r11d \\n&quot;\n\t&quot;call exit \\n&quot;\n);\n</code></pre>\n<p>The other significant change that had to be made was the PS4 has a customized ELF loader. The dynamic linking is custom, and there are additional non-standard / Sony-defined segments linked into PS4 apps. While most of these other segments are out of scope for this article, one of these segments is <code>.sce_process_param</code>. This segment defines metadata information, and needs to be linked into every application. Because of this, the CRT stub is a good location to put this segment in, as it'll always get linked with every application built with the toolchain.</p>\n<p>Some of this metadata information includes the version magic for &quot;ORBIS&quot; applications, entries for other specialized objects, the SDK version used to build the app, and other various information. Below is a snippet of this custom section; I won't paste the full thing for brevity's sake, but if you're interested, you can check this out by going to the port repo and looking at <code>/arch/ps4/crt_arch.h</code>.</p>\n<pre><code class=\"language-c\">__asm__(\n&quot;.intel_syntax noprefix \\n&quot;\n&quot;.align 0x8 \\n&quot;\n&quot;.section \\&quot;.data.sce_process_param\\&quot; \\n&quot;\n&quot;_sceProcessParam: \\n&quot;\n\t// size\n\t&quot;.quad \t0x50 \\n&quot;\n\t// magic &quot;ORBI&quot;\n\t&quot;.long   0x4942524F \\n&quot;\n\t// entry count\n\t&quot;.long \t0x3 \\n&quot;\n\t// ...\n);\n</code></pre>\n<h2 id=\"usingbsdsyscalls\">Using BSD Syscalls</h2>\n<p>As MUSL is a Linux-based libc, it's going to invoke Linux syscalls to bridge the gap between userland and kernel. Linux and FreeBSD have different sets of syscalls. While there are a lot of similarities (for example <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>), differences start to appear when you hit less common system calls. Luckily MUSL was written with this in mind, and provides the handy ability for custom &quot;architectures&quot; (more like targets) to be defined, which allows you to specify (among various other things), a set of input syscall identifiers.</p>\n<p>To define syscall numbers, MUSL reads the <code>/bits/syscall.h.in</code> file from the architecture directory.</p>\n<pre><code class=\"language-c\">#define\t__NR_syscall\t0\n#define\t__NR_exit\t1\n#define\t__NR_fork\t2\n// ...\n</code></pre>\n<p>The differences in syscalls between Linux and FreeBSD vary depending on the subsystem. For some (such as file I/O), the differences are little to none. For others, the difference is merely a different name or a few arguments switched around. In some cases though, the syscall straight up doesn't exist in BSD where it does in Linux. This is the case for things like fast user-space mutexes (or &quot;futexes&quot; for short). While porting to the PS4, I encountered all of these types of differences.</p>\n<p>In the case of different names, I just made alias definitions for the names MUSL expects and defined them to the BSD syscall that does the same thing. A good example of this is the set of syscalls used for signaling.</p>\n<pre><code class=\"language-c\">// Aliases for linux -&gt; BSD\n#define __NR_rt_sigqueueinfo    __NR_sigqueue\n#define __NR_rt_sigaction       __NR_sigaction\n#define __NR_rt_sigpending      __NR_sigpending\n// ...\n</code></pre>\n<p>In the harder to resolve cases like the system call not existing, it was always in exotic functionality, so I ifdef'd out calls to syscalls we didn't have. In the future, any functionality that needs implementing can be added in. The ifdef'ing was done to prevent breaking MUSL for non-PS4 architectures. This is illustrated by the <code>fanotify_init()</code> syscall, which does not exist on FreeBSD.</p>\n<pre><code class=\"language-c\">int fanotify_init(unsigned flags, unsigned event_f_flags)\n{\n#ifndef PS4\n\treturn syscall(SYS_fanotify_init, flags, event_f_flags);\n#else\n\treturn -1;\n#endif\n}\n</code></pre>\n<p>These are all the changes necessary to get MUSL to <em>build</em>, but you'll run into bugs at runtime. This is because of discrepancies between the kernel ABI of Linux and BSD.</p>\n<h2 id=\"kernelabidifferences\">Kernel ABI differences</h2>\n<p>The Application Binary Interface, or &quot;ABI&quot;, is basically a specification that outlines the calling convention to be followed, binary formats, dynamic linking, and other things. The calling convention is what's most important, because we need to know what registers are preserved, what registers are trashed and are volatile (aka. &quot;scratch&quot;) registers, and which registers are used for arguments and return values. Userland and kernel have slightly different calling conventions.</p>\n<p>Linux and BSD both use the &quot;System V&quot; or &quot;SYSV&quot; ABI specification. We're going to focus on the calling convention for the purposes of this article. Under SYSV, the following specifications apply:</p>\n<p><strong>Userland</strong></p>\n<p>For function calls:</p>\n<ul>\n<li>Registers <code>RBX</code>,  <code>RSP</code>, <code>RBP</code>, <code>R12</code>,  <code>R13</code>,  <code>R14</code>, and <code>R15</code> are preserved, meaning their values are saved by callee functions.</li>\n<li>Registers <code>RAX</code>, <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>, <code>R9</code>, <code>R10</code>, and <code>R11</code> are volatile / scratch registers, meaning their values are <em>not</em> saved by callee functions.</li>\n<li>For passing arguments and returning values, the following applies:\n<ul>\n<li>In order of 1st arg to 6th arg, registers <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>, and <code>R9</code> are used respectively. Beyond this, arguments are passed on the stack.</li>\n<li>The return value is stored in <code>RAX</code>.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Kernel</strong></p>\n<p>For system calls:</p>\n<ul>\n<li>Registers <code>RBX</code>, <code>RSP</code>, <code>RBP</code>, <code>R12</code>, <code>R13</code>, <code>R14</code>, and <code>R15</code> are preserved.</li>\n<li>For passing arguments, the following applies:\n<ul>\n<li>The <code>RAX</code> register is used to specify what system call index to invoke from the system call table.</li>\n<li>In order of 1st arg to 6th arg, registers <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>R10</code>, <code>R8</code>, and <code>R9</code> are used respectively.</li>\n<li>The first (and usually only) return value is stored in <code>RAX</code>.</li>\n<li>The second return value if it exists, is stored in <code>RBX</code>.</li>\n</ul>\n</li>\n<li>Register <code>RCX</code> is trashed by the kernel syscall exception handler to store the original instruction pointer value before the syscall.</li>\n<li><em>Usually</em>, while the argument registers are volatile in userland context, their values are saved and restored after a syscall by the syscall exception handler itself.</li>\n</ul>\n<h2 id=\"bug1whenbsdps4gaslightsyou\">Bug #1: When BSD/PS4 gaslights you</h2>\n<p>Notice in the last section I said <em>usually</em> the argument register values are saved and restored after a syscall with emphasis on &quot;usually&quot;. In Linux this is the case, and on FreeBSD this used to be the case. On the PS4 and on newer FreeBSD versions after January of 2019, this assumption is broken.</p>\n<p>From a system design point of view, you have to be careful with registers when switching privilege levels to and from kernel. You need to ensure you restore registers to their original values or otherwise change them before returning back to userland, ideally the former. For one, you don't want to &quot;bait and switch&quot; the register values out from underneath your userland caller if you can help it. Sometimes an argument register might be used to store data that's re-used later after the syscall returns, especially considering the argument registers are scratch registers, which are considered fair game by the compiler.</p>\n<p>The second and probably more important reason from a security point of view is you don't want to leak kernel register values to userland. Information disclosures like this can be powerful for exploitation, it can single handedly destroy kernel ASLR. It seems this was a concern, but rather than restoring the registers to their userland values pre-syscall, they instead opted to <strong>clear</strong> the register values by XOR'ing the registers with themselves before returning to userland. This galaxy brain idea causes issues! I only discovered this issue with the <code>R10</code> register, but I figured it's probably happening to more than just <code>R10</code>, so I checked out the <code>Xfast_syscall</code> exception handler for system calls in a PS4 kernel dump.</p>\n<pre><code class=\"language-assembly\">mov     rdi, qword [rsp]\nmov     rsi, qword [rsp+0x8]\nmov     rdx, qword [rsp+0x10]\nmov     rax, qword [rsp+0x30]\nmov     r11, qword [rsp+0xb8]\nmov     rcx, qword [rsp+0xa8]\nmov     rsp, qword [rsp+0xc0]\nxor     r8, r8  {0x0}\nxor     r9, r9  {0x0}\nxor     r10, r10  {0x0}\nswapgs  \nsysret  \n</code></pre>\n<p>Not only does it clear <code>R10</code>, it clears <code>R8</code> and <code>R9</code> as well. What's even more interesting is this code was added by Sony, as this code is not present in FreeBSD 9. But this code does exist in FreeBSD 12. If we look at the git blame for BSD's <code>/sys/amd64/amd64/exception.S</code> which contains exception handler implementations, we'll notice the following commit:</p>\n<p><a href=\"https://github.com/freebsd/freebsd/commit/84203fed6bace55a9e7f89d83cf74bd81603e91e\">https://github.com/freebsd/freebsd/commit/84203fed6bace55a9e7f89d83cf74bd81603e91e</a></p>\n<blockquote>\n<p>amd64: clear callee-preserved registers on syscall exit.</p>\n<p>%r8, %r10, and on non-KPTI configuration %r9 were not restored on fast<br>\nreturn from a syscall.</p>\n<p>Reviewed by:\tmarkj<br>\nApproved by:\tso<br>\nSecurity:\tCVE-2019-5595<br>\nSponsored by:\tThe FreeBSD Foundation<br>\nMFC after:\t0 minutes</p>\n</blockquote>\n<p>If we check out CVE-2019-5595:</p>\n<blockquote>\n<p>In FreeBSD before 11.2-STABLE(r343782), 11.2-RELEASE-p9,  12.0-STABLE(r343781), and 12.0-RELEASE-p3, kernel callee-save registers are not properly sanitized before return from system calls, potentially allowing some kernel data used in the system call to be exposed.</p>\n</blockquote>\n<p>As suspected. There was kernel information disclosure via the scratch registers. But instead of restoring them properly to userland-saved values, they just zero them out. I have no idea how this does not break assumptions when building BSD's libc, they must have some special code that's aware of it that I couldn't find. It's either that or there <em>were</em> bugs created by this issue that are yet undiscovered/disclosed.</p>\n<p>The odd thing here is the PS4 dump I looked at is 5.05 firmware, which was released in January of 2018. This commit in FreeBSD mainline however, was pushed in February of 2019. Sony knew about this problem before FreeBSD did by over a year. Either Sony reported this issue and it took a while to land in FreeBSD, or FreeBSD maintainers had to discover the issue independently later on. Due to the fix being very similar, I'd guess it's likely Sony had a hand in the mainline FreeBSD patch, as the fix is basically identical.</p>\n<p>This &quot;fix&quot; isn't optimal, because regular clang doesn't expect this behavior. Compilers like to be efficient, so it'll try to re-use registers where possible to avoid the performance cost of reloading a register. With this assumption broken, there are logic bugs introduced. Any time the compiler re-uses <code>R8</code>, <code>R9</code>, or <code>R10</code> after invoking a syscall, it will trigger undefined behavior. In the case of pointers, this causes null pointer dereferences in code that from the source level looks perfectly valid. This issue was discovered thanks to these null pointer dereferences.</p>\n<p>For example, <code>printf()</code> in MUSL calls a function called <code>__stdout_write</code>, which issues a <code>TIOCGWINSZ</code> ioctl syscall to get the window size. Here's the disassembly:</p>\n<p><img src=\"https://i.imgur.com/prfyUu8.png\" alt=\"\"></p>\n<p>This code looks OK until you consider <code>syscall</code> clobbers <code>R10</code>. Boom, null pointer dereference on the <code>mov dword [r10+0x90], -1</code> instruction. To workaround this, I modified the syscall wrappers to backup and restore these registers.</p>\n<pre><code class=\"language-c\">static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)\n{\n\t// ...\n    \n\t__asm__ __volatile__\n\t(\n\t\t&quot;.intel_syntax\\n\\t&quot;\n        &quot;push r8\\n\\t&quot;\n        &quot;push r9\\n\\t&quot;\n\t\t&quot;push r10\\n\\t&quot;\n\t\t&quot;syscall\\n\\t&quot;\n\t\t// ...\n        &quot;pop r10\\n\\t&quot;\n        &quot;pop r9\\n\\t&quot;\n        &quot;pop r8\\n\\t&quot; : &quot;=a&quot;(ret) :\n                       &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2), &quot;d&quot;(a3),\n                           &quot;r&quot;(r10), &quot;r&quot;(r8), &quot;r&quot;(r9) :\n                       &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;\n\t);\n    \n    return ret;\n}\n</code></pre>\n<h2 id=\"bug2syscallerrorhandling\">Bug #2: Syscall error handling</h2>\n<p>This bug was more my fault than anything, as I didn't realize SYSV did not extend beyond just defining the registers involved with error handling. It does <em>not</em> define how syscalls should indicate an error occurred and whether or not to return positive or negative errno values. In Linux, system calls on success return 0 or the positive value of whatever they should return (commonly a descriptor or a count). In cases of failure, a negative errno is returned. Expecting this, MUSL has a handler which checks if the return is <code>-4095 &lt;= RAX &lt;= -1</code>. If it's within this range, it sets errno appropriately by flipping the errno back to a positive by negating it, and returns -1.</p>\n<pre><code class=\"language-c\">long __syscall_ret(unsigned long r)\n{\n\tif (r &gt; -4096UL) {\n\t\terrno = -r;\n\t\treturn -1;\n\t}\n\treturn r;\n}\n</code></pre>\n<p>FreeBSD is a little different though. FreeBSD system calls return a positive errno, not a negative one. One may wonder how this works; how would you know the syscall had failed and the return value should be interpreted as an error rather than interpreted as valid data? It just so happens FreeBSD sets the carry flag or &quot;CF&quot; of <code>FLAGS</code> to 1 on error, and 0 on success.</p>\n<blockquote>\n<p>When using the standard FreeBSD calling convention, the <code>carry flag</code> is cleared upon success, set upon failure.</p>\n</blockquote>\n<p>It took me a bit of time to figure out how to do this in a way that didn't feel like a hack. I ended up doing a conditional jump based on the carry flag, and negated <code>RAX</code> if the flag was set. These changes were again added to the syscall wrappers.</p>\n<pre><code class=\"language-c\">static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)\n{\n\t// ...\n    \n\t__asm__ __volatile__\n\t(\n\t\t&quot;.intel_syntax\\n\\t&quot;\n    \t// ...\n\t\t&quot;syscall\\n\\t&quot;\n\t\t&quot;jnc syscallexit%=\\n\\t&quot;\n\t\t&quot;neg rax\\n\\t&quot;\n\t\t&quot;syscallexit%=:\\n\\t&quot;\n\t\t// ...\n    \t: &quot;=a&quot;(ret) : &quot;=a&quot;(ret) :\n                      &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2), &quot;d&quot;(a3),\n                          &quot;r&quot;(r10), &quot;r&quot;(r8), &quot;r&quot;(r9) :\n                      &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;\n\t);\n</code></pre>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>There are a lot of low-level factors to consider when porting something like a libc, and it's easy to get frustrated and fall victim to subtle discrepancies. To test the MUSL port, I wrote a suite of unit tests some readers may find interesting, and compiled it with the OpenOrbis PS4 Toolchain against the newly-built MUSL libc static library. Below you can find a link to the MUSL PS4 port [1], the mentioned set of tests [2], the test results directly from the PS4 [3], and other references.</p>\n<p>[1] <a href=\"https://github.com/OpenOrbis/musl\">https://github.com/OpenOrbis/musl</a></p>\n<p>[2] <a href=\"https://github.com/OpenOrbis/OpenOrbis-PS4-Toolchain/tree/master/samples\">https://github.com/OpenOrbis/OpenOrbis-PS4-Toolchain/tree/master/samples</a></p>\n<p>[3] <a href=\"https://pastebin.com/Wzvbdk8s\">https://pastebin.com/Wzvbdk8s</a></p>\n<p>[4] <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-5595\">https://nvd.nist.gov/vuln/detail/CVE-2019-5595</a></p>\n<p>[5] <a href=\"https://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/x86-return-values.html\">https://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/x86-return-values.html</a></p>\n<!--kg-card-end: markdown-->","authors":[{"name":"Specter","slug":"specter","profile_image":"https://dayzerosec.com/content/images/2019/11/specter-1.png"}],"tags":[{"id":"5ec9c2f2f8ecb90001b47549","title":"PS4","url":"https://dayzerosec.com/tag/ps4/","path":"ps4"},{"id":"5ec9c2f2f8ecb90001b4754a","title":"Low-level","url":"https://dayzerosec.com/tag/low-level/","path":"low-level"}],"slug":"adventures-of-porting-musl-to-ps4"}}]}}},"context":{}}