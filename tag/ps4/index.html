<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>PS4 - DAY[0]</title><meta name="gridsome:hash" content="bf1b6f9ce70f0ed231755bb903f8131dd6a1b1b9"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.13"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Reverse Engineering, Exploit Development, and other Security topics."><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.dc4b6c0d6f91bcea3090579aba64bf2a.png"><link rel="preload" href="/assets/css/0.styles.e61b4c8b.css" as="style"><link rel="preload" href="/assets/js/app.9ca08fe5.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--ghost-tag-vue.803754b8.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.303fd8d5.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.12bf0375.js"><link rel="prefetch" href="/assets/js/page--src--templates--ghost-author-vue.ddbab1e7.js"><link rel="prefetch" href="/assets/js/page--src--templates--ghost-post-vue.3d006341.js"><link rel="prefetch" href="/assets/js/page--src--templates--ghost-post-vue~page--src--templates--ghost-transcript-vue.e9a21cfa.js"><link rel="prefetch" href="/assets/js/page--src--templates--ghost-transcript-vue.34145503.js"><link rel="stylesheet" href="/assets/css/0.styles.e61b4c8b.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="active logo" data-v-4d8b4e1d><img src="/small-logo.png" data-v-4d8b4e1d><span data-v-4d8b4e1d></span></a></div><div class="header__right"></div></header><main class="main"><h1 class="tag-title text-center space-bottom">
    PS4
  </h1><div class="posts"><div class="post-card content-box"><div class="post-card__header"><!----></div><div class="post-card__content"><h2 class="post-card__title">Adventures of porting MUSL to PS4</h2><p class="post-card__description">Over the last year or so, I've been working with the OpenOrbis team to develop a toolchain for building homebrew for the PS4, and one of the challenges we faced was porting a proper libc to the console. This article dives into some of the interesting lessons learned while porting MUSL to the PS4.</p><div class="post-meta post-card__meta">
      24 May 2020
      <!----><!----></div><div class="post-tags post-card__tags"><a href="/tag/ps4" class="post-tags__link active--exact active">
			PS4
		</a><a href="/tag/low-level" class="post-tags__link">
			Low-level
		</a></div><a href="/posts/adventures-of-porting-musl-to-ps4" class="post-card__link">Link</a></div></div></div></main><div class="social-links-container"><div class="social-links"><div class="twitch"><a href="https://twitch.tv/dayzerosec"><img src="/social/twitch.png" alt="Twitch @dayzerosec"></a></div><div class="youtube"><a href="https://youtube.com/c/dayzerosec"><img src="/social/youtube.png" alt="Youtube @dayzerosec"></a></div><div class="twitter"><a href="https://twitter.com/dayzerosec"><img src="/social/twitter.png" alt="Twitter @dayzerosec"></a></div><div class="spotify"><a href="https://open.spotify.com/show/4NKCxk8aPEuEFuHsEQ9Tdt"><img src="/social/spotify.png" alt="Spotify @dayzerosec"></a></div><div class="github"><a href="https://github.com/dayzerosec"><img src="/social/github.png" alt="Github @dayzerosec"></a></div><div class="discord"><a href="https://discord.gg/daTxTK9"><img src="/social/discord.png" alt="Github @dayzerosec"></a></div></div></div><footer class="footer"><span class="footer__copyright">Copyright Â© 2020 dayzerosec.com </span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"tag":{"title":"PS4","slug":"ps4","path":"\u002Ftag\u002Fps4\u002F","belongsTo":{"edges":[{"node":{"title":"Adventures of porting MUSL to PS4","path":"\u002Fposts\u002Fadventures-of-porting-musl-to-ps4\u002F","date":"24 May 2020","description":"Over the last year or so, I've been working with the OpenOrbis team to develop a toolchain for building homebrew for the PS4, and one of the challenges we faced was porting a proper libc to the console. This article dives into some of the interesting lessons learned while porting MUSL to the PS4.","content":"\u003C!--kg-card-begin: markdown--\u003E\u003Cp\u003EOver the last year or so, I've been working with the OpenOrbis team to develop a toolchain for building homebrew to the PS4 without violating copyright laws by using the official SDK materials. This is not an easy task, building homebrew that will run on the system without official tools presents many challenges. Not only does your executable (ELF) have to adhere to the modifications made by Sony to the PS4's ELF loader, but the system also uses a modified libc. You could dynamically link with the system's, but you will have issues compiling against anything built on-top of libc, as we don't have access to the Sony-modified static libc library. Using the system libc also provides challenges when porting code from non-PS4 projects, as the Sony version breaks standards other libc libraries adhere to. To solve these issues, a proper libc port is needed. This article dives into some of the interesting hurdles and lessons we learned while porting \u003Ca href=\"https:\u002F\u002Fmusl.libc.org\u002F\"\u003EMUSL\u003C\u002Fa\u003E, a minimal and efficient libc library, to the PS4.\u003C\u002Fp\u003E\n\u003Ch2 id=\"overviewoflibc\"\u003EOverview of libc\u003C\u002Fh2\u003E\n\u003Cp\u003EMany developers treat libc as a black-box, they don't care how libc works, they just care that it does. This is perfectly fine when targeting an established platform that has a mature libc already working on it. When porting to a new platform however, you need to go into the nitty gritty details, because libc essentially acts as the glue between userland and kernel. For example, you will very rarely see userland applications issue system calls directly, but this is common-place in the world of libc. So if we break libc down, what are the fundamental components that are provided by libc to applications?\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EThe C Runtime (CRT) stub for initializing the environment, typically known as \u003Ccode\u003Ecrt1.o\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EA layer to abstract common functionality (ie. file I\u002FO, networking, data types, memory management) away from the platform's low-level interface (system calls, sysctls\u002Fioctls, etc).\u003C\u002Fli\u003E\n\u003Cli\u003EType definitions and objects for things like stdin, stdout, stderr, and error handling (errno).\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003EThese components must be tailored to the operating system and architecture being targeted.\u003C\u002Fp\u003E\n\u003Ch2 id=\"comparingbsdlibcandmusl\"\u003EComparing BSD libc and MUSL\u003C\u002Fh2\u003E\n\u003Cp\u003EFor those not familiar with PS4 internals, it's a FreeBSD based system, based on FreeBSD 9.0. Sony added their own system calls and modified some existing kernel code while also running a custom userland, but most of the standard syscalls are still pretty similar. Given it's a BSD system at base, one might ask; why not use BSD libc instead of MUSL - after all, it should match what the system exposes more closely? Knowing this, I decided to give it a shot. Here are some of my observations of both BSD libc and MUSL.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EBSD libc\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EIt was assumed BSD libc would work out of the box with minor CRT stub changes. It built without issue, but at runtime, this didn't end up being the case. Even something as simple as \u003Ccode\u003Esprintf()\u003C\u002Fcode\u003E failed with EINVAL, which is pretty incredible considering that's not even listed as a possible return value in the MAN pages. Bummer.\u003C\u002Fli\u003E\n\u003Cli\u003EIt requires a BSD system to build it, and you build it by building &quot;BSD world&quot;, which is massive and includes more than just libc. Navigating the codebase was far more difficult, and the code was less easy to work with.\u003C\u002Fli\u003E\n\u003Cli\u003EBecause of how much of a behemoth BSD world is, the build times were extremely long.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003EMUSL\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EMUSL definitely wouldn't work out of the box without some significant changes, as it's a Linux-based libc and we're dealing with BSD. Even getting it to build required changes.\u003C\u002Fli\u003E\n\u003Cli\u003EUnlike BSD world, MUSL is just a libc (and a minimal one at that). Fixing things was relatively easy and the code was readable and easily understood even if you're not familiar with the codebase.\u003C\u002Fli\u003E\n\u003Cli\u003EMUSL build times were blazingly fast compared to BSD libc. Where BSD libc would take about 20 minutes to build, building MUSL took closer to 2 minutes.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003EEven though in theory porting MUSL would take more changes than building a modified BSD libc, MUSL was the better option when we considered how much easier it was to work with and how much faster it was to build.\u003C\u002Fp\u003E\n\u003Ch2 id=\"acustomcrtstub\"\u003EA custom CRT stub\u003C\u002Fh2\u003E\n\u003Cp\u003EMost of the time, in C programs, \u003Ccode\u003Emain()\u003C\u002Fcode\u003E is not the true entry-point. While it's the entry-point as far as the application author is concerned, the real endpoint is usually \u003Ccode\u003E_start()\u003C\u002Fcode\u003E unless changed in the compiler flags or by a pre-processor directive. The reason for this is the C runtime wants to initialize it's environment before running any user-code. This is handled by the CRT stub. The bulk of the C runtime bootstrapping code is contained in the \u003Ccode\u003Ecrt1.o\u003C\u002Fcode\u003E object file. Generally in this file, you have the entry-point \u003Ccode\u003E_start()\u003C\u002Fcode\u003E, which calls \u003Ccode\u003E__libc_start_main()\u003C\u002Fcode\u003E, passing the address of the user-defined \u003Ccode\u003Emain()\u003C\u002Fcode\u003E which \u003Ccode\u003E__libc_start-main()\u003C\u002Fcode\u003E will execute after it finishes initializing environment-related stuff.\u003C\u002Fp\u003E\n\u003Cp\u003EThe PS4 is a little different in this regard, because the PS4 doesn't have a conventional environment or set of arguments provided to it. As a matter of fact, the PS4 doesn't even want applications to ever return, as attempting to return from main() will crash the game. This makes sense, as games do not need or use arguments, and games should never return unless the player quits the game or application. With this in mind, I ignored \u003Ccode\u003E__libc_start_main()\u003C\u002Fcode\u003E and defined my own \u003Ccode\u003E_start()\u003C\u002Fcode\u003E which matches closer to the one produced by BSD libc.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-assembly\"\u003E__asm__(\n&quot;.intel_syntax noprefix \\n&quot;\n&quot;.global &quot; START &quot; \\n&quot;\nSTART &quot;: \\n&quot;\n\t&quot;sub rsp, 0x28 \\n&quot;\n\t&quot;mov rdi, r8 \\n&quot;\n\t&quot;call atexit \\n&quot;\n\t&quot;xor edx, edx \\n&quot;\n\t&quot;mov edi, r9d \\n&quot;\n\t&quot;mov rsi, r10 \\n&quot;\n\t&quot;call main \\n&quot;\n\t&quot;mov r11d, eax \\n&quot;\n\t&quot;mov edi, r11d \\n&quot;\n\t&quot;call exit \\n&quot;\n);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe other significant change that had to be made was the PS4 has a customized ELF loader. The dynamic linking is custom, and there are additional non-standard \u002F Sony-defined segments linked into PS4 apps. While most of these other segments are out of scope for this article, one of these segments is \u003Ccode\u003E.sce_process_param\u003C\u002Fcode\u003E. This segment defines metadata information, and needs to be linked into every application. Because of this, the CRT stub is a good location to put this segment in, as it'll always get linked with every application built with the toolchain.\u003C\u002Fp\u003E\n\u003Cp\u003ESome of this metadata information includes the version magic for &quot;ORBIS&quot; applications, entries for other specialized objects, the SDK version used to build the app, and other various information. Below is a snippet of this custom section; I won't paste the full thing for brevity's sake, but if you're interested, you can check this out by going to the port repo and looking at \u003Ccode\u003E\u002Farch\u002Fps4\u002Fcrt_arch.h\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-c\"\u003E__asm__(\n&quot;.intel_syntax noprefix \\n&quot;\n&quot;.align 0x8 \\n&quot;\n&quot;.section \\&quot;.data.sce_process_param\\&quot; \\n&quot;\n&quot;_sceProcessParam: \\n&quot;\n\t\u002F\u002F size\n\t&quot;.quad \t0x50 \\n&quot;\n\t\u002F\u002F magic &quot;ORBI&quot;\n\t&quot;.long   0x4942524F \\n&quot;\n\t\u002F\u002F entry count\n\t&quot;.long \t0x3 \\n&quot;\n\t\u002F\u002F ...\n);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"usingbsdsyscalls\"\u003EUsing BSD Syscalls\u003C\u002Fh2\u003E\n\u003Cp\u003EAs MUSL is a Linux-based libc, it's going to invoke Linux syscalls to bridge the gap between userland and kernel. Linux and FreeBSD have different sets of syscalls. While there are a lot of similarities (for example \u003Ccode\u003Eopen()\u003C\u002Fcode\u003E, \u003Ccode\u003Eread()\u003C\u002Fcode\u003E, \u003Ccode\u003Ewrite()\u003C\u002Fcode\u003E, \u003Ccode\u003Eclose()\u003C\u002Fcode\u003E), differences start to appear when you hit less common system calls. Luckily MUSL was written with this in mind, and provides the handy ability for custom &quot;architectures&quot; (more like targets) to be defined, which allows you to specify (among various other things), a set of input syscall identifiers.\u003C\u002Fp\u003E\n\u003Cp\u003ETo define syscall numbers, MUSL reads the \u003Ccode\u003E\u002Fbits\u002Fsyscall.h.in\u003C\u002Fcode\u003E file from the architecture directory.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-c\"\u003E#define\t__NR_syscall\t0\n#define\t__NR_exit\t1\n#define\t__NR_fork\t2\n\u002F\u002F ...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe differences in syscalls between Linux and FreeBSD vary depending on the subsystem. For some (such as file I\u002FO), the differences are little to none. For others, the difference is merely a different name or a few arguments switched around. In some cases though, the syscall straight up doesn't exist in BSD where it does in Linux. This is the case for things like fast user-space mutexes (or &quot;futexes&quot; for short). While porting to the PS4, I encountered all of these types of differences.\u003C\u002Fp\u003E\n\u003Cp\u003EIn the case of different names, I just made alias definitions for the names MUSL expects and defined them to the BSD syscall that does the same thing. A good example of this is the set of syscalls used for signaling.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-c\"\u003E\u002F\u002F Aliases for linux -&gt; BSD\n#define __NR_rt_sigqueueinfo    __NR_sigqueue\n#define __NR_rt_sigaction       __NR_sigaction\n#define __NR_rt_sigpending      __NR_sigpending\n\u002F\u002F ...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EIn the harder to resolve cases like the system call not existing, it was always in exotic functionality, so I ifdef'd out calls to syscalls we didn't have. In the future, any functionality that needs implementing can be added in. The ifdef'ing was done to prevent breaking MUSL for non-PS4 architectures. This is illustrated by the \u003Ccode\u003Efanotify_init()\u003C\u002Fcode\u003E syscall, which does not exist on FreeBSD.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-c\"\u003Eint fanotify_init(unsigned flags, unsigned event_f_flags)\n{\n#ifndef PS4\n\treturn syscall(SYS_fanotify_init, flags, event_f_flags);\n#else\n\treturn -1;\n#endif\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThese are all the changes necessary to get MUSL to \u003Cem\u003Ebuild\u003C\u002Fem\u003E, but you'll run into bugs at runtime. This is because of discrepancies between the kernel ABI of Linux and BSD.\u003C\u002Fp\u003E\n\u003Ch2 id=\"kernelabidifferences\"\u003EKernel ABI differences\u003C\u002Fh2\u003E\n\u003Cp\u003EThe Application Binary Interface, or &quot;ABI&quot;, is basically a specification that outlines the calling convention to be followed, binary formats, dynamic linking, and other things. The calling convention is what's most important, because we need to know what registers are preserved, what registers are trashed and are volatile (aka. &quot;scratch&quot;) registers, and which registers are used for arguments and return values. Userland and kernel have slightly different calling conventions.\u003C\u002Fp\u003E\n\u003Cp\u003ELinux and BSD both use the &quot;System V&quot; or &quot;SYSV&quot; ABI specification. We're going to focus on the calling convention for the purposes of this article. Under SYSV, the following specifications apply:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EUserland\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EFor function calls:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERegisters \u003Ccode\u003ERBX\u003C\u002Fcode\u003E,  \u003Ccode\u003ERSP\u003C\u002Fcode\u003E, \u003Ccode\u003ERBP\u003C\u002Fcode\u003E, \u003Ccode\u003ER12\u003C\u002Fcode\u003E,  \u003Ccode\u003ER13\u003C\u002Fcode\u003E,  \u003Ccode\u003ER14\u003C\u002Fcode\u003E, and \u003Ccode\u003ER15\u003C\u002Fcode\u003E are preserved, meaning their values are saved by callee functions.\u003C\u002Fli\u003E\n\u003Cli\u003ERegisters \u003Ccode\u003ERAX\u003C\u002Fcode\u003E, \u003Ccode\u003ERDI\u003C\u002Fcode\u003E, \u003Ccode\u003ERSI\u003C\u002Fcode\u003E, \u003Ccode\u003ERDX\u003C\u002Fcode\u003E, \u003Ccode\u003ERCX\u003C\u002Fcode\u003E, \u003Ccode\u003ER8\u003C\u002Fcode\u003E, \u003Ccode\u003ER9\u003C\u002Fcode\u003E, \u003Ccode\u003ER10\u003C\u002Fcode\u003E, and \u003Ccode\u003ER11\u003C\u002Fcode\u003E are volatile \u002F scratch registers, meaning their values are \u003Cem\u003Enot\u003C\u002Fem\u003E saved by callee functions.\u003C\u002Fli\u003E\n\u003Cli\u003EFor passing arguments and returning values, the following applies:\n\u003Cul\u003E\n\u003Cli\u003EIn order of 1st arg to 6th arg, registers \u003Ccode\u003ERDI\u003C\u002Fcode\u003E, \u003Ccode\u003ERSI\u003C\u002Fcode\u003E, \u003Ccode\u003ERDX\u003C\u002Fcode\u003E, \u003Ccode\u003ERCX\u003C\u002Fcode\u003E, \u003Ccode\u003ER8\u003C\u002Fcode\u003E, and \u003Ccode\u003ER9\u003C\u002Fcode\u003E are used respectively. Beyond this, arguments are passed on the stack.\u003C\u002Fli\u003E\n\u003Cli\u003EThe return value is stored in \u003Ccode\u003ERAX\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003EKernel\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EFor system calls:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERegisters \u003Ccode\u003ERBX\u003C\u002Fcode\u003E, \u003Ccode\u003ERSP\u003C\u002Fcode\u003E, \u003Ccode\u003ERBP\u003C\u002Fcode\u003E, \u003Ccode\u003ER12\u003C\u002Fcode\u003E, \u003Ccode\u003ER13\u003C\u002Fcode\u003E, \u003Ccode\u003ER14\u003C\u002Fcode\u003E, and \u003Ccode\u003ER15\u003C\u002Fcode\u003E are preserved.\u003C\u002Fli\u003E\n\u003Cli\u003EFor passing arguments, the following applies:\n\u003Cul\u003E\n\u003Cli\u003EThe \u003Ccode\u003ERAX\u003C\u002Fcode\u003E register is used to specify what system call index to invoke from the system call table.\u003C\u002Fli\u003E\n\u003Cli\u003EIn order of 1st arg to 6th arg, registers \u003Ccode\u003ERDI\u003C\u002Fcode\u003E, \u003Ccode\u003ERSI\u003C\u002Fcode\u003E, \u003Ccode\u003ERDX\u003C\u002Fcode\u003E, \u003Ccode\u003ER10\u003C\u002Fcode\u003E, \u003Ccode\u003ER8\u003C\u002Fcode\u003E, and \u003Ccode\u003ER9\u003C\u002Fcode\u003E are used respectively.\u003C\u002Fli\u003E\n\u003Cli\u003EThe first (and usually only) return value is stored in \u003Ccode\u003ERAX\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EThe second return value if it exists, is stored in \u003Ccode\u003ERBX\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003ERegister \u003Ccode\u003ERCX\u003C\u002Fcode\u003E is trashed by the kernel syscall exception handler to store the original instruction pointer value before the syscall.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cem\u003EUsually\u003C\u002Fem\u003E, while the argument registers are volatile in userland context, their values are saved and restored after a syscall by the syscall exception handler itself.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"bug1whenbsdps4gaslightsyou\"\u003EBug #1: When BSD\u002FPS4 gaslights you\u003C\u002Fh2\u003E\n\u003Cp\u003ENotice in the last section I said \u003Cem\u003Eusually\u003C\u002Fem\u003E the argument register values are saved and restored after a syscall with emphasis on &quot;usually&quot;. In Linux this is the case, and on FreeBSD this used to be the case. On the PS4 and on newer FreeBSD versions after January of 2019, this assumption is broken.\u003C\u002Fp\u003E\n\u003Cp\u003EFrom a system design point of view, you have to be careful with registers when switching privilege levels to and from kernel. You need to ensure you restore registers to their original values or otherwise change them before returning back to userland, ideally the former. For one, you don't want to &quot;bait and switch&quot; the register values out from underneath your userland caller if you can help it. Sometimes an argument register might be used to store data that's re-used later after the syscall returns, especially considering the argument registers are scratch registers, which are considered fair game by the compiler.\u003C\u002Fp\u003E\n\u003Cp\u003EThe second and probably more important reason from a security point of view is you don't want to leak kernel register values to userland. Information disclosures like this can be powerful for exploitation, it can single handedly destroy kernel ASLR. It seems this was a concern, but rather than restoring the registers to their userland values pre-syscall, they instead opted to \u003Cstrong\u003Eclear\u003C\u002Fstrong\u003E the register values by XOR'ing the registers with themselves before returning to userland. This galaxy brain idea causes issues! I only discovered this issue with the \u003Ccode\u003ER10\u003C\u002Fcode\u003E register, but I figured it's probably happening to more than just \u003Ccode\u003ER10\u003C\u002Fcode\u003E, so I checked out the \u003Ccode\u003EXfast_syscall\u003C\u002Fcode\u003E exception handler for system calls in a PS4 kernel dump.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fi.imgur.com\u002FdGu4fhr.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ENot only does it clear \u003Ccode\u003ER10\u003C\u002Fcode\u003E, it clears \u003Ccode\u003ER8\u003C\u002Fcode\u003E and \u003Ccode\u003ER9\u003C\u002Fcode\u003E as well. What's even more interesting is this code was added by Sony, as this code is not present in FreeBSD 9. But this code does exist in FreeBSD 12. If we look at the git blame for BSD's \u003Ccode\u003E\u002Fsys\u002Famd64\u002Famd64\u002Fexception.S\u003C\u002Fcode\u003E which contains exception handler implementations, we'll notice the following commit:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffreebsd\u002Ffreebsd\u002Fcommit\u002F84203fed6bace55a9e7f89d83cf74bd81603e91e\"\u003Ehttps:\u002F\u002Fgithub.com\u002Ffreebsd\u002Ffreebsd\u002Fcommit\u002F84203fed6bace55a9e7f89d83cf74bd81603e91e\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003Eamd64: clear callee-preserved registers on syscall exit.\u003C\u002Fp\u003E\n\u003Cp\u003E%r8, %r10, and on non-KPTI configuration %r9 were not restored on fast\u003Cbr\u003E\nreturn from a syscall.\u003C\u002Fp\u003E\n\u003Cp\u003EReviewed by:\tmarkj\u003Cbr\u003E\nApproved by:\tso\u003Cbr\u003E\nSecurity:\tCVE-2019-5595\u003Cbr\u003E\nSponsored by:\tThe FreeBSD Foundation\u003Cbr\u003E\nMFC after:\t0 minutes\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EIf we check out CVE-2019-5595:\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EIn FreeBSD before 11.2-STABLE(r343782), 11.2-RELEASE-p9,  12.0-STABLE(r343781), and 12.0-RELEASE-p3, kernel callee-save registers are not properly sanitized before return from system calls, potentially allowing some kernel data used in the system call to be exposed.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EAs suspected. There was kernel information disclosure via the scratch registers. But instead of restoring them properly to userland-saved values, they just zero them out. I have no idea how this does not break assumptions when building BSD's libc, they must have some special code that's aware of it that I couldn't find. It's either that or there \u003Cem\u003Ewere\u003C\u002Fem\u003E bugs created by this issue that are yet undiscovered\u002Fdisclosed.\u003C\u002Fp\u003E\n\u003Cp\u003EThe odd thing here is the PS4 dump I looked at is 5.05 firmware, which was released in January of 2018. This commit in FreeBSD mainline however, was pushed in February of 2019. Sony knew about this problem before FreeBSD did by over a year. Either Sony reported this issue and it took a while to land in FreeBSD, or FreeBSD maintainers had to discover the issue independently later on. Due to the fix being very similar, I'd guess it's likely Sony had a hand in the mainline FreeBSD patch, as the fix is basically identical.\u003C\u002Fp\u003E\n\u003Cp\u003EThis &quot;fix&quot; isn't optimal, because regular clang doesn't expect this behavior. Compilers like to be efficient, so it'll try to re-use registers where possible to avoid the performance cost of reloading a register. With this assumption broken, there are logic bugs introduced. Any time the compiler re-uses \u003Ccode\u003ER8\u003C\u002Fcode\u003E, \u003Ccode\u003ER9\u003C\u002Fcode\u003E, or \u003Ccode\u003ER10\u003C\u002Fcode\u003E after invoking a syscall, it will trigger undefined behavior. In the case of pointers, this causes null pointer dereferences in code that from the source level looks perfectly valid. This issue was discovered thanks to these null pointer dereferences.\u003C\u002Fp\u003E\n\u003Cp\u003EFor example, \u003Ccode\u003Eprintf()\u003C\u002Fcode\u003E in MUSL calls a function called \u003Ccode\u003E__stdout_write\u003C\u002Fcode\u003E, which issues a \u003Ccode\u003ETIOCGWINSZ\u003C\u002Fcode\u003E ioctl syscall to get the window size. Here's the disassembly:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fi.imgur.com\u002FprfyUu8.png\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EThis code looks OK until you consider \u003Ccode\u003Esyscall\u003C\u002Fcode\u003E clobbers \u003Ccode\u003ER10\u003C\u002Fcode\u003E. Boom, null pointer dereference on the \u003Ccode\u003Emov dword [r10+0x90], -1\u003C\u002Fcode\u003E instruction. To workaround this, I modified the syscall wrappers to backup and restore these registers.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-c\"\u003Estatic __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)\n{\n\t\u002F\u002F ...\n    \n\t__asm__ __volatile__\n\t(\n\t\t&quot;.intel_syntax\\n\\t&quot;\n        &quot;push r8\\n\\t&quot;\n        &quot;push r9\\n\\t&quot;\n\t\t&quot;push r10\\n\\t&quot;\n\t\t&quot;syscall\\n\\t&quot;\n\t\t\u002F\u002F ...\n        &quot;pop r10\\n\\t&quot;\n        &quot;pop r9\\n\\t&quot;\n        &quot;pop r8\\n\\t&quot; : &quot;=a&quot;(ret) :\n                       &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2), &quot;d&quot;(a3),\n                           &quot;r&quot;(r10), &quot;r&quot;(r8), &quot;r&quot;(r9) :\n                       &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;\n\t);\n    \n    return ret;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"bug2syscallerrorhandling\"\u003EBug #2: Syscall error handling\u003C\u002Fh2\u003E\n\u003Cp\u003EThis bug was more my fault than anything, as I didn't realize SYSV did not extend beyond just defining the registers involved with error handling. It does \u003Cem\u003Enot\u003C\u002Fem\u003E define how syscalls should indicate an error occurred and whether or not to return positive or negative errno values. In Linux, system calls on success return 0 or the positive value of whatever they should return (commonly a descriptor or a count). In cases of failure, a negative errno is returned. Expecting this, MUSL has a handler which checks if the return is \u003Ccode\u003E-4095 &lt;= RAX &lt;= -1\u003C\u002Fcode\u003E. If it's within this range, it sets errno appropriately by flipping the errno back to a positive by negating it, and returns -1.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-c\"\u003Elong __syscall_ret(unsigned long r)\n{\n\tif (r &gt; -4096UL) {\n\t\terrno = -r;\n\t\treturn -1;\n\t}\n\treturn r;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EFreeBSD is a little different though. FreeBSD system calls return a positive errno, not a negative one. One may wonder how this works; how would you know the syscall had failed and the return value should be interpreted as an error rather than interpreted as valid data? It just so happens FreeBSD sets the carry flag or &quot;CF&quot; of \u003Ccode\u003EFLAGS\u003C\u002Fcode\u003E to 1 on error, and 0 on success.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EWhen using the standard FreeBSD calling convention, the \u003Ccode\u003Ecarry flag\u003C\u002Fcode\u003E is cleared upon success, set upon failure.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EIt took me a bit of time to figure out how to do this in a way that didn't feel like a hack. I ended up doing a conditional jump based on the carry flag, and negated \u003Ccode\u003ERAX\u003C\u002Fcode\u003E if the flag was set. These changes were again added to the syscall wrappers.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-c\"\u003Estatic __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)\n{\n\t\u002F\u002F ...\n    \n\t__asm__ __volatile__\n\t(\n\t\t&quot;.intel_syntax\\n\\t&quot;\n    \t\u002F\u002F ...\n\t\t&quot;syscall\\n\\t&quot;\n\t\t&quot;jnc syscallexit%=\\n\\t&quot;\n\t\t&quot;neg rax\\n\\t&quot;\n\t\t&quot;syscallexit%=:\\n\\t&quot;\n\t\t\u002F\u002F ...\n    \t: &quot;=a&quot;(ret) : &quot;=a&quot;(ret) :\n                      &quot;a&quot;(n), &quot;D&quot;(a1), &quot;S&quot;(a2), &quot;d&quot;(a3),\n                          &quot;r&quot;(r10), &quot;r&quot;(r8), &quot;r&quot;(r9) :\n                      &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;\n\t);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"conclusion\"\u003EConclusion\u003C\u002Fh2\u003E\n\u003Cp\u003EThere are a lot of low-level factors to consider when porting something like a libc, and it's easy to get frustrated and fall victim to subtle discrepancies. To test the MUSL port, I wrote a suite of unit tests some readers may find interesting, and compiled it with the OpenOrbis PS4 Toolchain against the newly-built MUSL libc static library. Below you can find a link to the MUSL PS4 port [1], the mentioned set of tests [2], the test results directly from the PS4 [3], and other references.\u003C\u002Fp\u003E\n\u003Cp\u003E[1] \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FOpenOrbis\u002Fmusl\"\u003Ehttps:\u002F\u002Fgithub.com\u002FOpenOrbis\u002Fmusl\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E[2] \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FOpenOrbis\u002FOpenOrbis-PS4-Toolchain\u002Ftree\u002Fmaster\u002Fsamples\"\u003Ehttps:\u002F\u002Fgithub.com\u002FOpenOrbis\u002FOpenOrbis-PS4-Toolchain\u002Ftree\u002Fmaster\u002Fsamples\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E[3] \u003Ca href=\"https:\u002F\u002Fpastebin.com\u002FWzvbdk8s\"\u003Ehttps:\u002F\u002Fpastebin.com\u002FWzvbdk8s\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E[4] \u003Ca href=\"https:\u002F\u002Fnvd.nist.gov\u002Fvuln\u002Fdetail\u002FCVE-2019-5595\"\u003Ehttps:\u002F\u002Fnvd.nist.gov\u002Fvuln\u002Fdetail\u002FCVE-2019-5595\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E[5] \u003Ca href=\"https:\u002F\u002Fwww.freebsd.org\u002Fdoc\u002Fen_US.ISO8859-1\u002Fbooks\u002Fdevelopers-handbook\u002Fx86-return-values.html\"\u003Ehttps:\u002F\u002Fwww.freebsd.org\u002Fdoc\u002Fen_US.ISO8859-1\u002Fbooks\u002Fdevelopers-handbook\u002Fx86-return-values.html\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C!--kg-card-end: markdown--\u003E","authors":[{"name":"Specter","slug":"specter","profile_image":"https:\u002F\u002Fdayzerosec.com\u002Fcontent\u002Fimages\u002F2019\u002F11\u002Fspecter-1.png"}],"tags":[{"id":"5ec9c2f2f8ecb90001b47549","title":"PS4","url":"https:\u002F\u002Fdayzerosec.com\u002Ftag\u002Fps4\u002F","path":"ps4"},{"id":"5ec9c2f2f8ecb90001b4754a","title":"Low-level","url":"https:\u002F\u002Fdayzerosec.com\u002Ftag\u002Flow-level\u002F","path":"low-level"}],"slug":"adventures-of-porting-musl-to-ps4"}}]}}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.9ca08fe5.js" defer></script><script src="/assets/js/page--src--templates--ghost-tag-vue.803754b8.js" defer></script>
  </body>
</html>